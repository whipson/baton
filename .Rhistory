test_path("test_pipelines/test_pipeline_daily_bad.R")
) |>
expect_error()
})
test_that("invalid tags trigger error", {
schedule_entry_from_script(
test_path("test_pipelines/test_pipeline_daily_bad.R")
) |>
expect_error(regexp = "Invalid batonFrequency")
})
res <- schedule_entry_from_script(
test_path("test_pipelines/test_multi_fun_pipeline.R")
)
expect_s3_class(res, "tbl_df")
expect_equal(nrow(res), 2)
expect_true(
all(
c("script_path", "func_name", "frequency", "interval",
"start_time", "tz") %in% names(res)
)
)
res
res <- schedule_entry_from_script(
test_path("test_pipelines/test_pipeline_daily_good.R")
)
res
expect_s3_class(res, "tbl_df")
expect_equal(nrow(res), 1)
expect_true(
all(
c("script_path", "func_name", "frequency", "interval",
"start_time", "tz") %in% names(res)
)
)
test_that("can create a schedule entry from a single well-documented fun", {
res <- schedule_entry_from_script(
test_path("test_pipelines/test_pipeline_daily_good.R")
)
expect_s3_class(res, "tbl_df")
expect_equal(nrow(res), 1)
expect_true(
all(
c("script_path", "func_name", "frequency", "interval",
"start_time", "tz") %in% names(res)
)
)
})
res <- schedule_entry_from_script(
test_path("test_pipelines/test_pipeline_daily_default.R")
)
expect_s3_class(res, "tbl_df")
expect_equal(nrow(res), 1)
expect_true(
all(
c("script_path", "func_name", "frequency", "interval",
"start_time", "tz") %in% names(res)
)
)
res
test_that("invalid tags trigger error", {
schedule_entry_from_script(
test_path("test_pipelines/test_pipeline_daily_bad.R")
) |>
expect_error(regexp = "Invalid batonFrequency")
})
schedule_entry_from_script(
test_path("test_pipelines/test_pipeline_daily_bad.R")
)
test_that("invalid tags trigger error", {
schedule_entry_from_script(
test_path("test_pipelines/test_pipeline_daily_bad.R")
) |>
expect_error(regexp = "Invalid batonFrequency")
})
res <- schedule_entry_from_script(
test_path("test_pipelines/test_multi_fun_pipeline.R")
)
expect_s3_class(res, "tbl_df")
res <- schedule_entry_from_script(
test_path("test_pipelines/test_multi_fun_pipeline.R")
)
res
# Create table entries
purrr::map2(func_names, baton_tag_vals, ~{
tibble::tibble(
script_path = script_path,
func_name = .x,
!!!.y
)
}) |>
purrr::list_rbind()
devtools::test()
example_schedule <- data.frame(
pipeline_name = c("pipeline1.R", "pipeline2.R", "pipeline3.R",
"pipeline4.R", "pipeline5.R"),
start_datetime = c("2024-01-01 07:05:00 AST", "2024-03-01 08:10:00 AST",
"2024-03-07 08:08:00 AST", "2024-02-29 14:25:00 AST",
"2024-02-01 06:45:00 AST"),
frequency = c("daily", "hourly", "hourly", "daily", "monthly"),
interval = 1
)
usethis::use_data(example_schedule, overwrite = TRUE)
example_schedule <- data.frame(
pipeline_name = c("pipeline1.R", "pipeline2.R", "pipeline3.R",
"pipeline4.R", "pipeline5.R"),
start_datetime = c("2024-01-01 07:05:00", "2024-03-01 08:10:00",
"2024-03-07 08:08:00", "2024-02-29 14:25:00",
"2024-02-01 06:45:00"),
frequency = c("daily", "hourly", "hourly", "daily", "monthly"),
interval = 1
)
usethis::use_data(example_schedule, overwrite = TRUE)
devtools::document()
devtools::document()
devtools::document()
lintr::lint_package()
devtools::load_all(".")
res <- generate_schedule_table(test_path("test_pipelines"))
generate_schedule_table("tests/testthat/test_pipelines/")
devtools::load_all(".")
generate_schedule_table("tests/testthat/test_pipelines/")
purrr::imap(pipelines, schedule_entry_from_script) |>
purrr::list_rbind() |>
# Supply default values for missing
dplyr::mutate(
frequency = dplyr::coalesce(frequency, "daily"),
interval = dplyr::coalesce(interval, 1L),
start_time = dplyr::coalesce(start_time, as.character(Sys.time())),
tz = dplyr::coalesce(tz, "UTC")
)
purrr::imap(pipelines, schedule_entry_from_script) |>
purrr::list_rbind()
purrr::map(pipelines, schedule_entry_from_script)
purrr::map(pipelines, schedule_entry_from_script) |>
purrr::list_rbind()
?purrr::possibly
attempted_sch_parses <- purrr::map(pipelines, purrr::possibly(schedule_entry_from_script))
attempted_sch_parses
attempted_sch_parses <- purrr::imap(pipelines, purrr::possibly(schedule_entry_from_script))
attempted_sch_parses
attempted_sch_parses <- purrr::map(pipelines, purrr::possibly(schedule_entry_from_script)) |>
setNames(pipelines)
attempted_sch_parses
attempted_sch_parses <- purrr::map(pipelines, purrr::possibly(schedule_entry_from_script)) |>
setNames(basename(pipelines))
attempted_sch_parses
renv::install("assertthat")
usethis::use_package("assertthat")
pipeline_dir <- "tests/testthat/test_pipelines/"
# Parse all the files in the `pipeline_dir` directory
pipelines <- list.files(pipeline_dir, full.names = TRUE)
attempted_sch_parses <- purrr::map(pipelines, purrr::possibly(schedule_entry_from_script)) |>
setNames(basename(pipelines))
attempted_sch_parses
skip(res <- generate_schedule_table(test_path("test_pipelines")))
devtools::load_all(".")
skip(res <- generate_schedule_table(test_path("test_pipelines")))
test_that("generate_schedule_table works on a directory of pipelines", {
skip(res <- generate_schedule_table(test_path("test_pipelines")))
})
test_that("generate_schedule_table works on a directory of pipelines", {
res <- generate_schedule_table(test_path("test_pipelines"))
}) |>
skip()
?skip
test_that("generate_schedule_table works on a directory of pipelines", {
skip()
res <- generate_schedule_table(test_path("test_pipelines"))
})
res <- schedule_entry_from_script(
test_path("test_pipelines/test_multi_fun_pipeline_one_bad.R")
)
res <- schedule_entry_from_script(
test_path("test_pipelines/test_multi_fun_pipeline_one_bad.R")
)
res <- schedule_entry_from_script(
test_path("test_pipelines/test_multi_fun_pipeline_one_bad.R")
)
devtools::load_all(".")
res <- schedule_entry_from_script(
test_path("test_pipelines/test_multi_fun_pipeline_one_bad.R")
)
tag_list
devtools::load_all(".")
res <- schedule_entry_from_script(
test_path("test_pipelines/test_multi_fun_pipeline_one_bad.R")
)
tag_list
# Get specifically the tags used by baton
baton_tag_vals <- purrr::map(tag_list, ~{
tag <- .x
val <- purrr::map(
baton_tag_names,
~{
val <- roxygen2::block_get_tag_value(tag, .x)
ifelse(is.null(val), NA, val)
}
)
val
})
baton_tag_vals
# Parse all the files in the `pipeline_dir` directory
pipelines <- list.files(pipeline_dir, full.names = TRUE)
attempted_sch_parses <- purrr::map(pipelines, purrr::possibly(schedule_entry_from_script)) |>
setNames(basename(pipelines))
devtools::load_all(".")
attempted_sch_parses <- purrr::map(pipelines, purrr::possibly(schedule_entry_from_script)) |>
setNames(basename(pipelines))
attempted_sch_parses
attempted_sch_parses <- purrr::map(pipelines, purrr::possibly(schedule_entry_from_script, quiet = FALSE)) |>
setNames(basename(pipelines))
attempted_sch_parses
attempted_sch_parses <- purrr::map(pipelines, purrr::safely(schedule_entry_from_script, quiet = FALSE)) |>
setNames(basename(pipelines))
attempted_sch_parses
attempted_sch_parses <- purrr::map(pipelines, purrr::safely(schedule_entry_from_script, quiet = FALSE)) |>
setNames(basename(pipelines)) |>
purrr::simplify_all()
attempted_sch_parses
attempted_sch_parses <- purrr::map(pipelines, purrr::safely(schedule_entry_from_script)) |>
setNames(basename(pipelines)) |>
purrr::simplify_all()
?purrr::simplify_all
# Try to generate a schedule entry for each script
# We use safely to ensure it continues in an error condition and capture the errors
attempted_sch_parses <- purrr::map(pipelines, purrr::safely(schedule_entry_from_script)) |>
setNames(basename(pipelines)) |>
purrr::list_simplify()
# Try to generate a schedule entry for each script
# We use safely to ensure it continues in an error condition and capture the errors
attempted_sch_parses <- purrr::map(pipelines, purrr::safely(schedule_entry_from_script)) |>
setNames(basename(pipelines))
attempted_sch_parses$test_multi_fun_pipeline_one_bad.R$result
sch_parse_error_idx <- purrr::map(attempted_sch_parses, ~.x$error)
sch_parse_error_idx
# Get the successful parses
success_sch_parses <- purrr::map(
attempted_sch_parses,
~.x$result
)
success_sch_parses
# Get the errors
sch_errors <- purrr::map(
attempted_sch_parses,
~.x$error
)
sch_errors
sch_errors[[1]]
sch_errors[[1]]$message
sch_errors[[1]]$parent
sch_results |>
purrr::list_rbind() |>
# Supply default values for missing
dplyr::mutate(
frequency = dplyr::coalesce(frequency, "daily"),
interval = dplyr::coalesce(interval, 1L),
start_time = dplyr::coalesce(start_time, as.character(Sys.time())),
tz = dplyr::coalesce(tz, "UTC")
) |>
dplyr::rowwise() |>
# Format timestamp with timezone
dplyr::mutate(
start_time = lubridate::as_datetime(start_time, tz = tz)
) |>
dplyr::ungroup()
# Get the results
sch_results <- purrr::map(
attempted_sch_parses,
~.x$result
)
sch_results |>
purrr::list_rbind() |>
# Supply default values for missing
dplyr::mutate(
frequency = dplyr::coalesce(frequency, "daily"),
interval = dplyr::coalesce(interval, 1L),
start_time = dplyr::coalesce(start_time, as.character(Sys.time())),
tz = dplyr::coalesce(tz, "UTC")
) |>
dplyr::rowwise() |>
# Format timestamp with timezone
dplyr::mutate(
start_time = lubridate::as_datetime(start_time, tz = tz)
) |>
dplyr::ungroup()
sch_errors
# Get the results
sch_results <- purrr::map(
attempted_sch_parses,
~.x$result
) |>
purrr::discard(is.null())
# Get the results
sch_results <- purrr::map(
attempted_sch_parses,
~.x$result
) |>
purrr::discard(is.null)
sch_results
# Get the errors
sch_errors <- purrr::map(
attempted_sch_parses,
~.x$error
) |>
purrr::discard(is.null)
sch_errors
parse_output <- attempted_sch_parses
parse_successes <- sch_results
parse_errors <- sch_results
parse_errors <- sch_errors
parse_successes
# Get the errors
sch_errors <- purrr::map(
attempted_sch_parses,
~.x$error
)
parse_errors <- sch_errors
parse_errors
n_pipes <- length(parse_errors)
n_fails <- purrr::discard(n_pipes, is.null)
purrr::discard(n_pipes, is.null)
n_fails <- purrr::discard(parse_errors, is.null)
n_fails <- length(fails)
fails <- purrr::discard(parse_errors, is.null)
n_fails <- length(fails)
cli::cli_alert_warning()
cli::cli_alert_warning("l")
cli::cli_h3("Some pipelines failed to parse")
cli::cli_warn(    cli::cli_h3("Some pipelines failed to parse"))
cli::cli_h3(cli::symbol$cross, "Some pipelines failed to parse")
cli::cli_h3("{cli::symbol$cross} Some pipelines failed to parse")
cli::cli_h3("{cli::symbol$cross} {n_fails} pipelines failed to parse")
cli::cli_h3("{cli::symbol$cross} {n_fails} pipeline(s) failed to parse")
cli::cli_alert_warning("{n_fails} pipeline(s) failed to parse")
parse_errors
names(parse_errors)
names(fails)
cli::cli_alert_warning("{n_fails} pipeline(s) failed to parse")
cli::cli_alert_warning("{n_fails} pipeline(s) failed to parse:")
fails[[1]]$message
names(fails[[1]])
fails
purrr::iwalk(fails[1:3], ~{
cli::cli_li(.y)
})
purrr::iwalk(fails[1:3], ~{
cli::cli_li(.y)
cli::col_red(.x$message)
})
fails[[1]]$message
purrr::iwalk(fails[1:3], ~{
cli::cli_li(.y)
cli::cli_text(cli::col_red(.x$message))
})
cli::cli_text(cli::col_orange(.x$message))
purrr::iwalk(fails[1:3], ~{
cli::cli_li(.y)
cli::cli_text(cli::col_grey(.x$message))
})
purrr::iwalk(fails[1:3], ~{
cli::cli_li(.y)
cli::cli_text(cli::col_silver(.x$message))
})
cli::cli_alert_warning("{n_fails} pipeline(s) failed to parse:")
# In this condition, we print the location and message
if(n_fails <= 3) {
purrr::iwalk(fails[1:3], ~{
cli::cli_li(.y)
cli::cli_text(cli::col_silver(.x$message))
})
}
purrr::iwalk(fails[1:3], ~{
cli::cli_li(.y)
cli::cli_text(cli::col_yellow(.x$message))
})
if (n_fails <= 3) {
purrr::iwalk(fails[1:3], ~{
cli::cli_li(.y)
cli::cli_text(cli::col_yellow(.x$message))
})
} else if (n_fails <= 6) {
purrr::iwalk(fails[1:6], ~{
cli::cli_li(.y)
})
}
if (n_fails <= 3) {
purrr::iwalk(fails[1:min(n_fails, 3)], ~{
cli::cli_li(.y)
cli::cli_text(cli::col_yellow(.x$message))
})
} else if (n_fails <= 6) {
purrr::iwalk(fails[1:min(n_fails, 6)], ~{
cli::col_yellow(cli::cli_li(.y))
})
}
if (n_fails <= 3) {
purrr::iwalk(fails[1:min(n_fails, 3)], ~{
cli::cli_li(.y)
cli::cli_text(cli::col_yellow(.x$message))
})
} else if (n_fails <= 6) {
purrr::iwalk(fails[1:min(n_fails, 6)], ~{
cli::cli_li(cli::col_yellow(.y))
})
}
cli::cli_inform("{n_additional} parsing errors. See all with {.fn baton_parse_errors()}")
n_additional <- n_fails - 6
cli::cli_inform("{n_additional} parsing errors. See all with {.fn baton_parse_errors()}")
n_additional <- n_fails - 6
cli::cli_inform("{n_additional} parsing errors. See all with {.fn baton_parse_errors}")
cli::cli_text("{n_additional} additional parsing error(s). See all with {.fn baton_parse_errors}")
n_additional <- n_fails - 6
cli::cli_text("{n_additional} additional parsing error(s)")
cli::cli_alert_info("See all with {.fn baton_parse_errors}")
devtools::load_all(".")
# Report the failed parses
btn_cli_gen_sch_tab_stat(sch_errors)
devtools::load_all(".")
# Report the failed parses
btn_cli_gen_sch_tab_stat(sch_errors)
devtools::load_all(".")
devtools::load_all(".")
baton_pkgenv
baton_pkgenv$errors
fails
fails[[1]]
fails[[1]]$rlang
fails[[1]]$message
devtools::load_all(".")
generate_schedule_table("tests/testthat/test_pipelines/")
res <- generate_schedule_table("tests/testthat/test_pipelines/")
latest_parsing_errors()
test_that("generate_schedule_table works on a directory of pipelines
that includes parsing errors", {
res <- generate_schedule_table(test_path("test_pipelines")) |>
expect_message(regexp = "pipeline(s) failed to parse")
})
res <- generate_schedule_table(test_path("test_pipelines")) |>
expect_message(regexp = "pipeline(s) failed to parse")
res <- generate_schedule_table(test_path("test_pipelines"))
res <- generate_schedule_table(test_path("test_pipelines"))
res <- generate_schedule_table(test_path("test_pipelines")) |>
expect_message()
expect_s3_class(res, "tbl_df")
res
res <- generate_schedule_table(test_path("test_pipelines")) |>
expect_message()
res <- generate_schedule_table(test_path("test_pipelines"))
generate_schedule_table(test_path("test_pipelines"))
res <- generate_schedule_table(test_path("test_pipelines")) |>
expect_message()
View(res)
devtools::load_all(".")
res <- generate_schedule_table(test_path("test_pipelines")) |>
expect_message()
devtools::load_all(".")
res <- generate_schedule_table(test_path("test_pipelines")) |>
expect_message()
res
res$trace
res$call
devtools::load_all(".")
res <- generate_schedule_table(test_path("test_pipelines")) |>
expect_message()
res
res <- generate_schedule_table(test_path("test_pipelines"))
res
res <- generate_schedule_table(test_path("test_pipelines")) |>
expect_message()
res
?expect_message
res <- generate_schedule_table(test_path("test_pipelines")) |>
expect_warning()
res <- generate_schedule_table(test_path("test_pipelines")) |>
expect_message()
res <- generate_schedule_table(test_path("test_pipelines"))
generate_schedule_table(test_path("test_pipelines"))
generate_schedule_table(test_path("test_pipelines")) |>
expect_message()
generate_schedule_table(test_path("test_pipelines")) |>
expect_message()
test_that(
"generate_schedule_table works on a directory of pipelines
that includes parsing errors",
{
generate_schedule_table(test_path("test_pipelines")) |>
expect_message()
res <- generate_schedule_table(test_path("test_pipelines"))
expect_s3_class(res, "tbl_df")
})
?cli::test_that_cli
res <- expect_snapshot(
generate_schedule_table(test_path("test_pipelines"))
)
cli::test_that_cli(
"generate_schedule_table works on a directory of pipelines
that includes parsing errors",
{
res <- expect_snapshot(
generate_schedule_table(test_path("test_pipelines"))
)
res <- generate_schedule_table(test_path("test_pipelines"))
expect_s3_class(res, "tbl_df")
})
cli::test_that_cli(
"generate_schedule_table works on a directory of pipelines
that includes parsing errors",
{
res <- expect_snapshot(
generate_schedule_table(test_path("test_pipelines"))
)
})
