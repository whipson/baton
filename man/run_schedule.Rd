% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_schedule.R
\name{run_schedule}
\alias{run_schedule}
\title{Run a schedule}
\usage{
run_schedule(
  schedule,
  orch_interval = 1,
  orch_frequency = "day",
  check_datetime = lubridate::now(tzone = "UTC"),
  resources = list(),
  run_all = FALSE,
  n_show_next = 5,
  cores = 1,
  quiet = FALSE
)
}
\arguments{
\item{schedule}{a table of scheduled pipelines generated from \code{build_schedule()}}

\item{orch_interval}{a numeric value representing how often the orchestration runs}

\item{orch_frequency}{unit of how often the orchestration runs (i.e. min, hour, day, month, etc.)}

\item{check_datetime}{datetime used to check against the pipeline start datetime}

\item{resources}{named list of shared resources made available to pipelines as needed}

\item{run_all}{run all pipelines regardless of the schedule (default is \code{FALSE}) - useful for testing.
Does not apply to pipes with a \code{maestroSkip} tag.}

\item{n_show_next}{show the next n scheduled pipes}

\item{cores}{number of cpu cores to run if running in parallel. If > 1, \code{furrr} is used and
a multisession plan must be executed in the orchestrator (see details)}

\item{quiet}{print metrics to the console (default = \code{TRUE})}
}
\value{
invisible
}
\description{
Given a schedule in a \code{maestro} project, runs the pipelines that are scheduled to execute
based on the current time.
}
\details{
\subsection{Pipeline schedule logic}{

The function \code{run_schedule()} examines each pipeline in the schedule table and determines
whether it is scheduled to run at the current time using some simple time arithmetic. We assume
\code{run_schedule(schedule, check_datetime = Sys.time())}, but this need not be the case.
}

\subsection{Pipelines with arguments (resources)}{

If a pipeline takes an argument that doesn't include a default value, these can be supplied
in the orchestrator via \code{run_schedule(resources = list(arg1 = val))}. The name of the argument
used by the pipeline must match the name of the argument in the list. Currently, each named
resource must refer to a single object. In other words, you can't have two pipes using
the same argument but requiring different values.
}

\subsection{Running in parallel}{

Pipelines can be run in parallel using the \code{cores} argument. First, you must run \code{future::plan(future::multisession)}
in the orchestrator. Then, supply the desired number of cores to the \code{cores} argument. Note that
console output appears different in multicore mode.
}
}
